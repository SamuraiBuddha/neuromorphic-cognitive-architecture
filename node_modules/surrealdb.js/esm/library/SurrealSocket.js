import { WebsocketStatus, } from "../types.js";
import WebSocket from "./WebSocket/node.js";
import { getIncrementalID } from "./getIncrementalID.js";
import { processUrl } from "./processUrl.js";
export class SurrealSocket {
    constructor({ url, onConnect, onClose, onError, }) {
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ws", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: WebsocketStatus.CLOSED
        });
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "liveQueue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "unprocessedLiveResponses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveClosed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "socketClosureReason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                1000: "CLOSE_NORMAL",
            }
        });
        this.hooks = { onConnect, onClose, onError };
        this.url = processUrl(url, {
            http: "ws",
            https: "wss",
        }) + "/rpc";
    }
    open() {
        // Close any possibly connected sockets, reset status;
        this.close(1000);
        // Connect to Surreal instance
        let resolved = false;
        const ws = new WebSocket(this.url);
        this.ready = new Promise((resolve, reject) => {
            ws.addEventListener("open", (_e) => {
                this.status = WebsocketStatus.OPEN;
                if (!resolved) {
                    resolved = true;
                    resolve();
                }
                this.hooks.onConnect?.();
            });
            ws.addEventListener("error", (e) => {
                this.status = WebsocketStatus.CLOSED;
                if (!resolved) {
                    resolved = true;
                    reject("error" in e ? e.error : e.toString());
                    this.hooks.onError?.();
                }
            });
        });
        ws.addEventListener("close", (_e) => {
            this.resolveClosed?.();
            Object.values(this.liveQueue).map((query) => {
                query.map((cb) => cb({
                    action: "CLOSE",
                    detail: "SOCKET_CLOSED",
                }));
            });
            this.queue = {};
            this.liveQueue = {};
            this.unprocessedLiveResponses = {};
            // Connection retry mechanism
            if (this.status !== WebsocketStatus.CLOSED) {
                this.status = WebsocketStatus.RECONNECTING;
                setTimeout(() => {
                    this.open();
                }, 2500);
                this.hooks.onClose?.();
            }
        });
        ws.addEventListener("message", (e) => {
            const res = JSON.parse(e.data.toString());
            if (SurrealSocket.isLiveNotification(res)) {
                this.handleLiveBatch(res.result);
            }
            else if (res.id && res.id in this.queue) {
                this.queue[res.id](res);
                delete this.queue[res.id];
            }
        });
        this.ws = ws;
        return this.ready;
    }
    // Extracting the pure object to prevent any getters/setters that could break stuff
    // Prevent user from overwriting ID that is being sent
    async send(method, params, callback) {
        await this.ready;
        const id = getIncrementalID();
        this.queue[id] = callback;
        this.ws?.send(JSON.stringify({ id, method, params }));
    }
    async listenLive(queryUuid, callback) {
        if (!(queryUuid in this.liveQueue))
            this.liveQueue[queryUuid] = [];
        this.liveQueue[queryUuid].push(callback);
        // Cleanup unprocessed messages queue
        await Promise.all(this.unprocessedLiveResponses[queryUuid]?.map(callback) ?? []);
        delete this.unprocessedLiveResponses[queryUuid];
    }
    async kill(queryUuid) {
        if (queryUuid in this.liveQueue) {
            this.liveQueue[queryUuid].forEach((cb) => cb({
                action: "CLOSE",
                detail: "QUERY_KILLED",
            }));
            delete this.liveQueue[queryUuid];
        }
        await new Promise((r) => {
            this.send("kill", [queryUuid], (_) => {
                if (queryUuid in this.unprocessedLiveResponses) {
                    delete this.unprocessedLiveResponses[queryUuid];
                }
                r();
            });
        });
    }
    async handleLiveBatch({ id: queryUuid, ...message }) {
        if (this.liveQueue[queryUuid]) {
            await Promise.all(this.liveQueue[queryUuid].map(async (cb) => await cb(message)));
        }
        else {
            if (!(queryUuid in this.unprocessedLiveResponses)) {
                this.unprocessedLiveResponses[queryUuid] = [];
            }
            this.unprocessedLiveResponses[queryUuid].push(message);
        }
    }
    async close(reason) {
        this.status = WebsocketStatus.CLOSED;
        this.closed = new Promise((r) => this.resolveClosed = r);
        this.ws?.close(reason, this.socketClosureReason[reason]);
        this.hooks.onClose?.();
        await this.closed;
    }
    get connectionStatus() {
        return this.status;
    }
    static isLiveNotification(message) {
        return !!(!("id" in message) &&
            "result" in message &&
            typeof message.result === "object" &&
            message.result !== null &&
            "action" in message.result &&
            "id" in message.result &&
            "result" in message.result);
    }
}
//# sourceMappingURL=SurrealSocket.js.map