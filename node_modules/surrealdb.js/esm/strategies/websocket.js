import { NoActiveSocket, UnexpectedResponse } from "../errors.js";
import { Pinger } from "../library/Pinger.js";
import { SurrealSocket } from "../library/SurrealSocket.js";
import { processAuthVars } from "../library/processAuthVars.js";
import { AnyAuth, processConnectionOptions, ScopeAuth, Token, TransformAuth, } from "../types.js";
export class WebSocketStrategy {
    constructor(hooks = {}) {
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pinger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rejectReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ws"
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.hooks = hooks;
    }
    /**
     * Establish a socket connection to the database
     * @param connection - Connection details
     */
    async connect(url, opts = {}) {
        const { prepare, auth, namespace, database } = processConnectionOptions(opts);
        this.ready = new Promise((resolve, reject) => {
            this.resolveReady = resolve;
            this.rejectReady = reject;
        });
        this.connection = {
            auth,
            namespace,
            database,
        };
        this.socket?.close(1000);
        this.pinger = new Pinger(30000);
        this.socket = new SurrealSocket({
            url,
            onConnect: async () => {
                this.pinger?.start(() => this.ping());
                if (this.connection.namespace && this.connection.database) {
                    await this.use({});
                }
                if (typeof this.connection.auth === "string") {
                    await this.authenticate(this.connection.auth);
                }
                else if (this.connection.auth) {
                    await this.signin(this.connection.auth);
                }
                await prepare?.(this);
                this.resolveReady?.();
                this.hooks.onConnect?.();
            },
            onClose: () => {
                this.pinger?.stop();
                this.hooks.onClose?.();
            },
            onError: this.hooks.onError,
        });
        await this.socket.open().catch(this.rejectReady);
        return this.ready;
    }
    /**
     * Disconnect the socket to the database
     */
    async close() {
        await this.socket?.close(1000);
        this.socket = undefined;
    }
    /**
     * Check if connection is ready
     */
    async wait() {
        if (!this.socket)
            throw new NoActiveSocket();
        await this.ready;
    }
    /**
     * Get status of the socket connection
     */
    get status() {
        if (!this.socket)
            throw new NoActiveSocket();
        return this.socket.connectionStatus;
    }
    /**
     * Ping SurrealDB instance
     */
    async ping() {
        const { error } = await this.send("ping");
        if (error)
            throw new Error(error.message);
    }
    /**
     * Switch to a specific namespace and database.
     * @param database - Switches to a specific namespace.
     * @param db - Switches to a specific database.
     */
    async use({ namespace, database }) {
        if (!namespace && !this.connection.namespace) {
            throw new Error("Please specify a namespace to use.");
        }
        if (!database && !this.connection.database) {
            throw new Error("Please specify a database to use.");
        }
        this.connection.namespace = namespace ?? this.connection.namespace;
        this.connection.database = database ?? this.connection.database;
        const { error } = await this.send("use", [
            this.connection.namespace,
            this.connection.database,
        ]);
        if (error)
            throw new Error(error.message);
    }
    /**
     * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.
     * ```sql
     * SELECT * FROM $auth;
     * ```
     * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result.
     * @return The record linked to the record ID used for authentication
     */
    async info() {
        await this.ready;
        const res = await this.send("info");
        if (res.error)
            throw new Error(res.error.message);
        return res.result ?? undefined;
    }
    /**
     * Signs up to a specific authentication scope.
     * @param vars - Variables used in a signup query.
     * @return The authentication token.
     */
    async signup(vars) {
        vars = ScopeAuth.parse(vars);
        vars = processAuthVars(vars, {
            namespace: this.connection.namespace,
            database: this.connection.database,
        });
        const res = await this.send("signup", [
            TransformAuth.parse(vars),
        ]);
        if (res.error)
            throw new Error(res.error.message);
        if (!res.result) {
            throw new Error("Did not receive authentication token");
        }
        this.connection.auth = res.result;
        return res.result;
    }
    /**
     * Signs in to a specific authentication scope.
     * @param vars - Variables used in a signin query.
     * @return The authentication token.
     */
    async signin(vars) {
        vars = AnyAuth.parse(vars);
        vars = processAuthVars(vars, {
            namespace: this.connection.namespace,
            database: this.connection.database,
        });
        const res = await this.send("signin", [
            TransformAuth.parse(vars),
        ]);
        if (res.error)
            throw new Error(res.error.message);
        if (!res.result) {
            throw new Error("Did not receive authentication token");
        }
        this.connection.auth = res.result;
        return res.result;
    }
    /**
     * Authenticates the current connection with a JWT token.
     * @param token - The JWT authentication token.
     */
    async authenticate(token) {
        const res = await this.send("authenticate", [
            Token.parse(token),
        ]);
        if (res.error)
            throw new Error(res.error.message);
        this.connection.auth = token;
        return !!token;
    }
    /**
     * Invalidates the authentication for the current connection.
     */
    async invalidate() {
        const res = await this.send("invalidate");
        if (res.error)
            throw new Error(res.error.message);
        this.connection.auth = undefined;
    }
    /**
     * Specify a variable for the current socket connection.
     * @param key - Specifies the name of the variable.
     * @param val - Assigns the value to the variable name.
     */
    async let(variable, value) {
        const res = await this.send("let", [variable, value]);
        if (res.error)
            throw new Error(res.error.message);
    }
    /**
     * Remove a variable from the current socket connection.
     * @param key - Specifies the name of the variable.
     */
    async unset(variable) {
        const res = await this.send("unset", [variable]);
        if (res.error)
            throw new Error(res.error.message);
    }
    /**
     * Start a live query and listen for the responses
     * @param table - The table that you want to receive live results for.
     * @param callback - Callback function that receives updates.
     * @param diff - If set to true, will return a set of patches instead of complete records
     */
    async live(table, callback, diff) {
        await this.ready;
        const res = await this.send("live", [table, diff]);
        if (res.error)
            throw new Error(res.error.message);
        if (callback)
            this.listenLive(res.result, callback);
        return res.result;
    }
    /**
     * Listen for live query responses by it's uuid
     * @param queryUuid - The LQ uuid that you want to receive live results for.
     * @param callback - Callback function that receives updates.
     */
    async listenLive(queryUuid, callback) {
        await this.ready;
        if (!this.socket)
            throw new NoActiveSocket();
        this.socket.listenLive(queryUuid, callback);
    }
    /**
     * Kill a live query
     * @param uuid - The query that you want to kill.
     */
    async kill(queryUuid) {
        await this.ready;
        if (!this.socket)
            throw new NoActiveSocket();
        await this.socket.kill(queryUuid);
    }
    /**
     * Runs a set of SurrealQL statements against the database.
     * @param query - Specifies the SurrealQL statements.
     * @param bindings - Assigns variables which can be used in the query.
     */
    async query(query, bindings) {
        const raw = await this.query_raw(query, bindings);
        return raw.map(({ status, result, detail }) => {
            if (status == "ERR")
                throw new Error(detail ?? result);
            return result;
        });
    }
    /**
     * Runs a set of SurrealQL statements against the database.
     * @param query - Specifies the SurrealQL statements.
     * @param bindings - Assigns variables which can be used in the query.
     */
    async query_raw(query, bindings) {
        if (typeof query !== "string") {
            bindings = bindings ?? {};
            bindings = { ...bindings, ...query.bindings };
            query = query.query;
        }
        await this.ready;
        const res = await this.send("query", [
            query,
            bindings,
        ]);
        if (res.error)
            throw new Error(res.error.message);
        return res.result;
    }
    /**
     * Selects all records in a table, or a specific record, from the database.
     * @param thing - The table name or a record ID to select.
     */
    async select(thing) {
        await this.ready;
        const res = await this.send("select", [thing]);
        return this.outputHandler(res);
    }
    /**
     * Creates a record in the database.
     * @param thing - The table name or the specific record ID to create.
     * @param data - The document / record data to insert.
     */
    async create(thing, data) {
        await this.ready;
        const res = await this.send("create", [
            thing,
            data,
        ]);
        return this.outputHandler(res);
    }
    /**
     * Inserts one or multiple records in the database.
     * @param thing - The table name or the specific record ID to create.
     * @param data - The document(s) / record(s) to insert.
     */
    async insert(thing, data) {
        await this.ready;
        const res = await this.send("insert", [
            thing,
            data,
        ]);
        return this.outputHandler(res);
    }
    /**
     * Updates all records in a table, or a specific record, in the database.
     *
     * ***NOTE: This function replaces the current document / record data with the specified data.***
     * @param thing - The table name or the specific record ID to update.
     * @param data - The document / record data to insert.
     */
    async update(thing, data) {
        await this.ready;
        const res = await this.send("update", [
            thing,
            data,
        ]);
        return this.outputHandler(res);
    }
    /**
     * Modifies all records in a table, or a specific record, in the database.
     *
     * ***NOTE: This function merges the current document / record data with the specified data.***
     * @param thing - The table name or the specific record ID to change.
     * @param data - The document / record data to insert.
     */
    async merge(thing, data) {
        await this.ready;
        const res = await this.send("merge", [thing, data]);
        return this.outputHandler(res);
    }
    /**
     * Applies JSON Patch changes to all records, or a specific record, in the database.
     *
     * ***NOTE: This function patches the current document / record data with the specified JSON Patch data.***
     * @param thing - The table name or the specific record ID to modify.
     * @param data - The JSON Patch data with which to modify the records.
     */
    async patch(thing, data) {
        await this.ready;
        const res = await this.send("patch", [thing, data]);
        return this.outputHandler(res);
    }
    /**
     * Deletes all records in a table, or a specific record, from the database.
     * @param thing - The table name or a record ID to select.
     */
    async delete(thing) {
        await this.ready;
        const res = await this.send("delete", [thing]);
        return this.outputHandler(res);
    }
    /**
     * Send a raw message to the SurrealDB instance
     * @param method - Type of message to send.
     * @param params - Parameters for the message.
     */
    send(method, params) {
        return new Promise((resolve, reject) => {
            if (!this.socket)
                throw new NoActiveSocket();
            this.socket
                .send(method, params ?? [], (r) => resolve(r))
                .catch((e) => reject(e));
        });
    }
    /**
     * Process a response by the SurrealDB instance
     * @param res - The raw response
     * @param thing - What thing did you query (table vs record).
     */
    outputHandler(res) {
        if (res.error)
            throw new Error(res.error.message);
        if (Array.isArray(res.result)) {
            return res.result;
        }
        else if ("id" in (res.result ?? {})) {
            return [res.result];
        }
        else if (res.result === null) {
            return [];
        }
        console.debug({ res });
        throw new UnexpectedResponse();
    }
}
//# sourceMappingURL=websocket.js.map