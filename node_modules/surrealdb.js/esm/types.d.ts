import { z } from "zod";
import { PreparedQuery } from "./index.js";
export type ConnectionStrategy = "websocket" | "experimental_http";
export interface Connection {
    constructor: Constructor<(hooks: StatusHooks) => void>;
    strategy: "ws" | "http";
    connect: (url: string, options?: ConnectionOptions) => void;
    ping: () => Promise<void>;
    use: (opt: {
        namespace: string;
        database: string;
    }) => MaybePromise<void>;
    info?: <T extends Record<string, unknown> = Record<string, unknown>>() => Promise<T | undefined>;
    signup: (vars: ScopeAuth) => Promise<Token>;
    signin: (vars: AnyAuth) => Promise<Token | void>;
    authenticate: (token: Token) => MaybePromise<boolean>;
    invalidate: () => MaybePromise<void>;
    let?: (variable: string, value: unknown) => Promise<void>;
    unset?: (variable: string) => Promise<void>;
    live?: <T extends Record<string, unknown>>(table: string, callback?: (data: LiveQueryResponse<T>) => unknown, diff?: boolean) => Promise<string>;
    listenLive?: <T extends Record<string, unknown>>(queryUuid: string, callback: (data: LiveQueryResponse<T>) => unknown) => Promise<void>;
    kill?: (queryUuid: string) => Promise<void>;
    query: <T extends RawQueryResult[]>(query: string | PreparedQuery, bindings?: Record<string, unknown>) => Promise<T>;
    query_raw: <T extends RawQueryResult[]>(query: string | PreparedQuery, bindings?: Record<string, unknown>) => Promise<MapQueryResult<T>>;
    select: <T extends Record<string, unknown>>(thing: string) => Promise<ActionResult<T>[]>;
    create: <T extends Record<string, unknown>, U extends Record<string, unknown> = T>(thing: string, data?: U) => Promise<ActionResult<T, U>[]>;
    insert?: <T extends Record<string, unknown>, U extends Record<string, unknown> = T>(thing: string, data?: U | U[]) => Promise<ActionResult<T, U>[]>;
    update: <T extends Record<string, unknown>, U extends Record<string, unknown> = T>(thing: string, data?: U) => Promise<ActionResult<T, U>[]>;
    merge: <T extends Record<string, unknown>, U extends Record<string, unknown> = Partial<T>>(thing: string, data?: U) => Promise<ActionResult<T, U>[]>;
    patch?: (thing: string, data?: Patch[]) => Promise<Patch[]>;
    delete: <T extends Record<string, unknown>>(thing: string) => Promise<ActionResult<T>[]>;
}
export type StatusHooks = {
    onConnect?: () => unknown;
    onClose?: () => unknown;
    onError?: () => unknown;
};
export declare const UseOptions: z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    database: string;
}, {
    namespace: string;
    database: string;
}>;
export type UseOptions = z.infer<typeof UseOptions>;
export type ActionResult<T extends Record<string, unknown>, U extends Record<string, unknown> = T> = T & U & {
    id: string;
};
export declare const SuperUserAuth: z.ZodObject<{
    namespace: z.ZodOptional<z.ZodNever>;
    database: z.ZodOptional<z.ZodNever>;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    username: string;
    password: string;
    namespace?: undefined;
    database?: undefined;
    scope?: undefined;
}, {
    username: string;
    password: string;
    namespace?: undefined;
    database?: undefined;
    scope?: undefined;
}>;
export type SuperUserAuth = z.infer<typeof SuperUserAuth>;
export declare const NamespaceAuth: z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodOptional<z.ZodNever>;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    username: string;
    password: string;
    database?: undefined;
    scope?: undefined;
}, {
    namespace: string;
    username: string;
    password: string;
    database?: undefined;
    scope?: undefined;
}>;
export type NamespaceAuth = z.infer<typeof NamespaceAuth>;
export declare const DatabaseAuth: z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    database: string;
    username: string;
    password: string;
    scope?: undefined;
}, {
    namespace: string;
    database: string;
    username: string;
    password: string;
    scope?: undefined;
}>;
export type DatabaseAuth = z.infer<typeof DatabaseAuth>;
export declare const ScopeAuth: z.ZodObject<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, "strip", z.ZodUnknown, z.objectOutputType<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">, z.objectInputType<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">>;
export type ScopeAuth = z.infer<typeof ScopeAuth>;
export declare const AnyAuth: z.ZodUnion<[z.ZodObject<{
    namespace: z.ZodOptional<z.ZodNever>;
    database: z.ZodOptional<z.ZodNever>;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    username: string;
    password: string;
    namespace?: undefined;
    database?: undefined;
    scope?: undefined;
}, {
    username: string;
    password: string;
    namespace?: undefined;
    database?: undefined;
    scope?: undefined;
}>, z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodOptional<z.ZodNever>;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    username: string;
    password: string;
    database?: undefined;
    scope?: undefined;
}, {
    namespace: string;
    username: string;
    password: string;
    database?: undefined;
    scope?: undefined;
}>, z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    database: string;
    username: string;
    password: string;
    scope?: undefined;
}, {
    namespace: string;
    database: string;
    username: string;
    password: string;
    scope?: undefined;
}>, z.ZodObject<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, "strip", z.ZodUnknown, z.objectOutputType<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">, z.objectInputType<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">>]>;
export type AnyAuth = z.infer<typeof AnyAuth>;
export declare const Token: z.ZodString;
export type Token = z.infer<typeof Token>;
export declare const TransformAuth: z.ZodUnion<[z.ZodEffects<z.ZodObject<{
    namespace: z.ZodOptional<z.ZodString>;
    database: z.ZodOptional<z.ZodString>;
    scope: z.ZodOptional<z.ZodNever>;
    username: z.ZodString;
    password: z.ZodString;
}, "strip", z.ZodTypeAny, {
    username: string;
    password: string;
    namespace?: string | undefined;
    database?: string | undefined;
    scope?: undefined;
}, {
    username: string;
    password: string;
    namespace?: string | undefined;
    database?: string | undefined;
    scope?: undefined;
}>, {
    ns: string | undefined;
    db: string | undefined;
    user: string;
    pass: string;
}, {
    username: string;
    password: string;
    namespace?: string | undefined;
    database?: string | undefined;
    scope?: undefined;
}>, z.ZodEffects<z.ZodObject<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodString;
}, "strip", z.ZodUnknown, z.objectOutputType<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">, z.objectInputType<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">>, {
    ns: string;
    db: string;
    sc: string;
}, z.objectInputType<{
    namespace: z.ZodString;
    database: z.ZodString;
    scope: z.ZodString;
}, z.ZodUnknown, "strip">>]>;
export declare const HTTPAuthenticationResponse: z.ZodDiscriminatedUnion<"code", [z.ZodObject<{
    code: z.ZodLiteral<200>;
    details: z.ZodString;
    token: z.ZodString;
}, "strip", z.ZodTypeAny, {
    code: 200;
    details: string;
    token: string;
}, {
    code: 200;
    details: string;
    token: string;
}>, z.ZodObject<{
    code: z.ZodLiteral<403>;
    details: z.ZodString;
    description: z.ZodString;
    information: z.ZodString;
}, "strip", z.ZodTypeAny, {
    code: 403;
    details: string;
    description: string;
    information: string;
}, {
    code: 403;
    details: string;
    description: string;
    information: string;
}>]>;
export type HTTPAuthenticationResponse = z.infer<typeof HTTPAuthenticationResponse>;
export type Result<T = unknown> = ResultOk<T> | ResultErr;
export type ResultOk<T> = {
    result: T;
    error?: never;
};
export type ResultErr = {
    result?: never;
    error: {
        code: number;
        message: string;
    };
};
export type QueryResult<T = unknown> = QueryResultOk<T> | QueryResultErr;
export type QueryResultOk<T> = {
    status: "OK";
    time: string;
    result: T;
    detail?: never;
};
export type QueryResultErr = {
    status: "ERR";
    time: string;
    result?: never;
    detail: string;
};
export type MapQueryResult<T> = {
    [K in keyof T]: QueryResult<T[K]>;
};
export type RawQueryResult = string | number | boolean | symbol | null | RawQueryResult[] | Record<string | number | symbol, unknown>;
export type LiveQueryClosureReason = "SOCKET_CLOSED" | "QUERY_KILLED";
export type LiveQueryResponse<T extends Record<string, unknown> = Record<string, unknown>> = {
    action: "CLOSE";
    result?: never;
    detail: LiveQueryClosureReason;
} | {
    action: "CREATE" | "UPDATE" | "DELETE";
    result: T;
    detail?: never;
};
export type UnprocessedLiveQueryResponse<T extends Record<string, unknown> = Record<string, unknown>> = LiveQueryResponse<T> & {
    id: string;
};
type BasePatch<T = string> = {
    path: T;
};
export type AddPatch<T = string, U = unknown> = BasePatch<T> & {
    op: "add";
    value: U;
};
export type RemovePatch<T = string> = BasePatch<T> & {
    op: "remove";
};
export type ReplacePatch<T = string, U = unknown> = BasePatch<T> & {
    op: "replace";
    value: U;
};
export type ChangePatch<T = string, U = string> = BasePatch<T> & {
    op: "change";
    value: U;
};
export type CopyPatch<T = string, U = string> = BasePatch<T> & {
    op: "copy";
    from: U;
};
export type MovePatch<T = string, U = string> = BasePatch<T> & {
    op: "move";
    from: U;
};
export type TestPatch<T = string, U = unknown> = BasePatch<T> & {
    op: "test";
    value: U;
};
export type Patch = AddPatch | RemovePatch | ReplacePatch | ChangePatch | CopyPatch | MovePatch | TestPatch;
export declare enum WebsocketStatus {
    OPEN = 0,
    CLOSED = 1,
    RECONNECTING = 2
}
export type InvalidSQL = {
    code: 400;
    details: "Request problems detected";
    description: "There is a problem with your request. Refer to the documentation for further information.";
    information: string;
};
export declare const HTTPConstructorOptions: z.ZodObject<{
    fetch: z.ZodOptional<z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, {
    fetch?: ((...args: unknown[]) => unknown) | undefined;
}, {
    fetch?: ((...args: unknown[]) => unknown) | undefined;
}>;
export type HTTPConstructorOptions<TFetcher = typeof fetch> = {
    fetch?: TFetcher;
};
type Constructor<T> = Function & {
    prototype: T;
};
type MaybePromise<T> = T | Promise<T>;
export type RawSocketMessageResponse = (Result & {
    id: number;
}) | RawSocketLiveQueryNotification;
export type RawSocketLiveQueryNotification = {
    result: UnprocessedLiveQueryResponse;
};
export type ConnectionOptions = {
    prepare?: (connection: Connection) => unknown;
    auth?: AnyAuth | Token;
} & (UseOptions | {
    namespace?: never;
    database?: never;
});
export declare function processConnectionOptions({ prepare, auth, namespace, database, }: ConnectionOptions): {
    namespace: string;
    database: string;
    prepare: ((connection: Connection) => unknown) | undefined;
    auth: string | z.objectOutputType<{
        namespace: z.ZodOptional<z.ZodString>;
        database: z.ZodOptional<z.ZodString>;
        scope: z.ZodString;
    }, z.ZodUnknown, "strip"> | {
        username: string;
        password: string;
        namespace?: undefined;
        database?: undefined;
        scope?: undefined;
    } | {
        namespace: string;
        username: string;
        password: string;
        database?: undefined;
        scope?: undefined;
    } | {
        namespace: string;
        database: string;
        username: string;
        password: string;
        scope?: undefined;
    } | undefined;
} | {
    namespace: undefined;
    database: undefined;
    prepare: ((connection: Connection) => unknown) | undefined;
    auth: string | z.objectOutputType<{
        namespace: z.ZodOptional<z.ZodString>;
        database: z.ZodOptional<z.ZodString>;
        scope: z.ZodString;
    }, z.ZodUnknown, "strip"> | {
        username: string;
        password: string;
        namespace?: undefined;
        database?: undefined;
        scope?: undefined;
    } | {
        namespace: string;
        username: string;
        password: string;
        database?: undefined;
        scope?: undefined;
    } | {
        namespace: string;
        database: string;
        username: string;
        password: string;
        scope?: undefined;
    } | undefined;
};
export {};
