import { z } from "zod";
export const UseOptions = z.object({
    namespace: z.coerce.string(),
    database: z.coerce.string(),
});
//////////////////////////////////////////////
//////////   AUTHENTICATION TYPES   //////////
//////////////////////////////////////////////
export const SuperUserAuth = z.object({
    namespace: z.never().optional(),
    database: z.never().optional(),
    scope: z.never().optional(),
    username: z.coerce.string(),
    password: z.coerce.string(),
});
export const NamespaceAuth = z.object({
    namespace: z.coerce.string(),
    database: z.never().optional(),
    scope: z.never().optional(),
    username: z.coerce.string(),
    password: z.coerce.string(),
});
export const DatabaseAuth = z.object({
    namespace: z.coerce.string(),
    database: z.coerce.string(),
    scope: z.never().optional(),
    username: z.coerce.string(),
    password: z.coerce.string(),
});
export const ScopeAuth = z.object({
    namespace: z.coerce.string().optional(),
    database: z.coerce.string().optional(),
    scope: z.coerce.string(),
}).catchall(z.unknown());
export const AnyAuth = z.union([
    SuperUserAuth,
    NamespaceAuth,
    DatabaseAuth,
    ScopeAuth,
]);
export const Token = z.string({ invalid_type_error: "Not a valid token" });
export const TransformAuth = z.union([
    z.object({
        namespace: z.string().optional(),
        database: z.string().optional(),
        scope: z.never().optional(),
        username: z.string(),
        password: z.string(),
    }).transform(({ namespace, database, username, password, }) => ({
        ns: namespace,
        db: database,
        user: username,
        pass: password,
    })),
    z.object({
        namespace: z.string(),
        database: z.string(),
        scope: z.string(),
    }).catchall(z.unknown()).transform(({ namespace, database, scope, ...rest }) => ({
        ns: namespace,
        db: database,
        sc: scope,
        ...rest,
    })),
]);
export const HTTPAuthenticationResponse = z.discriminatedUnion("code", [
    z.object({
        code: z.literal(200),
        details: z.string(),
        token: z.string({
            required_error: "Did not recieve an authentication token",
            invalid_type_error: "Received an invalid token",
        }),
    }),
    z.object({
        code: z.literal(403),
        details: z.string(),
        description: z.string(),
        information: z.string(),
    }),
], { invalid_type_error: "Unexpected authentication response" });
///////////////////////////////////
//////////   WEBSOCKET   //////////
///////////////////////////////////
export var WebsocketStatus;
(function (WebsocketStatus) {
    WebsocketStatus[WebsocketStatus["OPEN"] = 0] = "OPEN";
    WebsocketStatus[WebsocketStatus["CLOSED"] = 1] = "CLOSED";
    WebsocketStatus[WebsocketStatus["RECONNECTING"] = 2] = "RECONNECTING";
})(WebsocketStatus || (WebsocketStatus = {}));
export const HTTPConstructorOptions = z.object({
    fetch: z.function().optional(),
});
export function processConnectionOptions({ prepare, auth, namespace, database, }) {
    z.function().optional().parse(prepare);
    z.union([Token, AnyAuth]).optional().parse(auth);
    const useOpts = namespace || database
        ? UseOptions.parse({
            namespace,
            database,
        })
        : { namespace: undefined, database: undefined };
    return { prepare, auth, ...useOpts };
}
//# sourceMappingURL=types.js.map