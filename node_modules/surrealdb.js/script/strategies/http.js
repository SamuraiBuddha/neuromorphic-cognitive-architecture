"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPStrategy = void 0;
const errors_js_1 = require("../errors.js");
const SurrealHTTP_js_1 = require("../library/SurrealHTTP.js");
const processAuthVars_js_1 = require("../library/processAuthVars.js");
const types_js_1 = require("../types.js");
class HTTPStrategy {
    /**
     * Establish a socket connection to the database
     * @param connection - Connection details
     */
    constructor(opts = {}) {
        Object.defineProperty(this, "http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "http"
        });
        types_js_1.HTTPConstructorOptions.parse(opts);
        this.fetch = opts.fetch ?? fetch;
        this.resolveReady = () => { }; // Purely for typescript typing :)
        this.ready = new Promise((r) => (this.resolveReady = r));
    }
    /**
     * Establish a socket connection to the database
     * @param connection - Connection details
     */
    async connect(url, opts = {}) {
        const { prepare, auth, namespace, database } = (0, types_js_1.processConnectionOptions)(opts);
        this.http = new SurrealHTTP_js_1.SurrealHTTP(url, { fetch: this.fetch });
        await this.use({ namespace, database });
        if (typeof auth === "string") {
            await this.authenticate(auth);
        }
        else if (auth) {
            await this.signin(auth);
        }
        await prepare?.(this);
        this.resolveReady();
        await this.ready;
    }
    /**
     * Disconnect the socket to the database
     */
    close() {
        this.http = undefined;
        this.resetReady();
    }
    /**
     * Check if connection is ready
     */
    wait() {
        if (!this.http)
            throw new errors_js_1.NoConnectionDetails();
        return this.ready;
    }
    /**
     * Get status of the socket connection
     */
    get status() {
        return this.request("/status");
    }
    /**
     * Ping SurrealDB instance
     */
    async ping() {
        await this.request("/health");
    }
    /**
     * Switch to a specific namespace and database.
     * @param database - Switches to a specific namespace.
     * @param db - Switches to a specific database.
     */
    use(opt) {
        if (!this.http)
            throw new errors_js_1.NoConnectionDetails();
        const { namespace, database } = types_js_1.UseOptions.partial().strict().parse(opt);
        if (namespace)
            this.http.namespace = namespace;
        if (database)
            this.http.database = database;
    }
    /**
     * Signs up to a specific authentication scope.
     * @param vars - Variables used in a signup query.
     * @return The authentication token.
     */
    async signup(vars) {
        vars = types_js_1.ScopeAuth.parse(vars);
        vars = (0, processAuthVars_js_1.processAuthVars)(vars, {
            namespace: this.http?.namespace,
            database: this.http?.database,
        });
        const res = await this.request("/signup", {
            method: "POST",
            body: types_js_1.TransformAuth.parse(vars),
        }).then(types_js_1.HTTPAuthenticationResponse.parse);
        if (res.code === 403)
            throw new Error(res.description);
        this.http?.setTokenAuth(res.token);
        return res.token;
    }
    /**
     * Signs in to a specific authentication scope.
     * @param vars - Variables used in a signin query.
     * @return The authentication token, unless signed in as root.
     */
    async signin(vars) {
        vars = types_js_1.AnyAuth.parse(vars);
        vars = (0, processAuthVars_js_1.processAuthVars)(vars, {
            namespace: this.http?.namespace,
            database: this.http?.database,
        });
        const res = await this.request("/signin", {
            method: "POST",
            body: types_js_1.TransformAuth.parse(vars),
        }).then(types_js_1.HTTPAuthenticationResponse.parse);
        if (res.code === 403)
            throw new Error(res.description);
        this.http?.setTokenAuth(res.token);
        return res.token;
    }
    /**
     * Authenticates the current connection with a JWT token.
     * @param token - The JWT authentication token.
     */
    authenticate(token) {
        this.http?.setTokenAuth(types_js_1.Token.parse(token));
        return true;
    }
    /**
     * Invalidates the authentication for the current connection.
     */
    invalidate() {
        this.http?.clearAuth();
    }
    /**
     * Runs a set of SurrealQL statements against the database.
     * @param query - Specifies the SurrealQL statements.
     * @param bindings - Assigns variables which can be used in the query.
     */
    async query(query, bindings) {
        const raw = await this.query_raw(query, bindings);
        return raw.map(({ status, result, detail }) => {
            if (status == "ERR")
                throw new Error(detail ?? result);
            return result;
        });
    }
    /**
     * Runs a set of SurrealQL statements against the database.
     * @param query - Specifies the SurrealQL statements.
     * @param bindings - Assigns variables which can be used in the query.
     */
    async query_raw(query, bindings) {
        if (typeof query !== "string") {
            bindings = bindings ?? {};
            bindings = { ...bindings, ...query.bindings };
            query = query.query;
        }
        await this.ready;
        const res = await this.request("/sql", {
            body: query,
            plainBody: true,
            method: "POST",
            searchParams: bindings &&
                new URLSearchParams(Object.fromEntries(Object.entries(bindings).map(([k, v]) => [
                    k,
                    JSON.stringify(v),
                ]))),
        });
        if ("information" in res)
            throw new Error(res.information);
        return res;
    }
    /**
     * Selects all records in a table, or a specific record, from the database.
     * @param thing - The table name or a record ID to select.
     */
    async select(thing) {
        await this.ready;
        const url = `/key/${this.modifyThing(thing)}`;
        const [res] = await this.request(url, {
            method: "GET",
        });
        if (res.status == "ERR")
            throw new Error(res.detail);
        return res.result;
    }
    /**
     * Creates a record in the database.
     * @param thing - The table name or the specific record ID to create.
     * @param data - The document / record data to insert.
     */
    async create(thing, data) {
        await this.ready;
        const url = `/key/${this.modifyThing(thing)}`;
        const [res] = await this.request(url, {
            method: "POST",
            body: data,
        });
        if (res.status == "ERR")
            throw new Error(res.detail);
        return res.result;
    }
    /**
     * Updates all records in a table, or a specific record, in the database.
     *
     * ***NOTE: This function replaces the current document / record data with the specified data.***
     * @param thing - The table name or the specific record ID to update.
     * @param data - The document / record data to insert.
     */
    async update(thing, data) {
        await this.ready;
        const url = `/key/${this.modifyThing(thing)}`;
        const [res] = await this.request(url, {
            method: "PUT",
            body: data,
        });
        if (res.status == "ERR")
            throw new Error(res.detail);
        return res.result;
    }
    /**
     * Modifies all records in a table, or a specific record, in the database.
     *
     * ***NOTE: This function merges the current document / record data with the specified data.***
     * @param thing - The table name or the specific record ID to change.
     * @param data - The document / record data to insert.
     */
    async merge(thing, data) {
        await this.ready;
        const url = `/key/${this.modifyThing(thing)}`;
        const [res] = await this.request(url, {
            method: "PATCH",
            body: data,
        });
        if (res.status == "ERR")
            throw new Error(res.detail);
        return res.result;
    }
    /**
     * Deletes all records in a table, or a specific record, from the database.
     * @param thing - The table name or a record ID to select.
     */
    async delete(thing) {
        await this.ready;
        const url = `/key/${this.modifyThing(thing)}`;
        const [res] = await this.request(url, {
            method: "DELETE",
        });
        if (res.status == "ERR")
            throw new Error(res.detail);
        return res.result;
    }
    get request() {
        if (!this.http)
            throw new errors_js_1.NoConnectionDetails();
        return this.http.request.bind(this.http);
    }
    /**
     * Reset the ready mechanism.
     */
    resetReady() {
        this.ready = new Promise((r) => (this.resolveReady = r));
    }
    modifyThing(thing) {
        const regex = /([^`:⟨⟩]+|\`.+\`|⟨.+⟩):([^`:⟨⟩]+|\`.+\`|⟨.+⟩)/;
        thing = thing.replace(regex, "$1/$2");
        return thing;
    }
}
exports.HTTPStrategy = HTTPStrategy;
//# sourceMappingURL=http.js.map