"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processConnectionOptions = exports.HTTPConstructorOptions = exports.WebsocketStatus = exports.HTTPAuthenticationResponse = exports.TransformAuth = exports.Token = exports.AnyAuth = exports.ScopeAuth = exports.DatabaseAuth = exports.NamespaceAuth = exports.SuperUserAuth = exports.UseOptions = void 0;
const zod_1 = require("zod");
exports.UseOptions = zod_1.z.object({
    namespace: zod_1.z.coerce.string(),
    database: zod_1.z.coerce.string(),
});
//////////////////////////////////////////////
//////////   AUTHENTICATION TYPES   //////////
//////////////////////////////////////////////
exports.SuperUserAuth = zod_1.z.object({
    namespace: zod_1.z.never().optional(),
    database: zod_1.z.never().optional(),
    scope: zod_1.z.never().optional(),
    username: zod_1.z.coerce.string(),
    password: zod_1.z.coerce.string(),
});
exports.NamespaceAuth = zod_1.z.object({
    namespace: zod_1.z.coerce.string(),
    database: zod_1.z.never().optional(),
    scope: zod_1.z.never().optional(),
    username: zod_1.z.coerce.string(),
    password: zod_1.z.coerce.string(),
});
exports.DatabaseAuth = zod_1.z.object({
    namespace: zod_1.z.coerce.string(),
    database: zod_1.z.coerce.string(),
    scope: zod_1.z.never().optional(),
    username: zod_1.z.coerce.string(),
    password: zod_1.z.coerce.string(),
});
exports.ScopeAuth = zod_1.z.object({
    namespace: zod_1.z.coerce.string().optional(),
    database: zod_1.z.coerce.string().optional(),
    scope: zod_1.z.coerce.string(),
}).catchall(zod_1.z.unknown());
exports.AnyAuth = zod_1.z.union([
    exports.SuperUserAuth,
    exports.NamespaceAuth,
    exports.DatabaseAuth,
    exports.ScopeAuth,
]);
exports.Token = zod_1.z.string({ invalid_type_error: "Not a valid token" });
exports.TransformAuth = zod_1.z.union([
    zod_1.z.object({
        namespace: zod_1.z.string().optional(),
        database: zod_1.z.string().optional(),
        scope: zod_1.z.never().optional(),
        username: zod_1.z.string(),
        password: zod_1.z.string(),
    }).transform(({ namespace, database, username, password, }) => ({
        ns: namespace,
        db: database,
        user: username,
        pass: password,
    })),
    zod_1.z.object({
        namespace: zod_1.z.string(),
        database: zod_1.z.string(),
        scope: zod_1.z.string(),
    }).catchall(zod_1.z.unknown()).transform(({ namespace, database, scope, ...rest }) => ({
        ns: namespace,
        db: database,
        sc: scope,
        ...rest,
    })),
]);
exports.HTTPAuthenticationResponse = zod_1.z.discriminatedUnion("code", [
    zod_1.z.object({
        code: zod_1.z.literal(200),
        details: zod_1.z.string(),
        token: zod_1.z.string({
            required_error: "Did not recieve an authentication token",
            invalid_type_error: "Received an invalid token",
        }),
    }),
    zod_1.z.object({
        code: zod_1.z.literal(403),
        details: zod_1.z.string(),
        description: zod_1.z.string(),
        information: zod_1.z.string(),
    }),
], { invalid_type_error: "Unexpected authentication response" });
///////////////////////////////////
//////////   WEBSOCKET   //////////
///////////////////////////////////
var WebsocketStatus;
(function (WebsocketStatus) {
    WebsocketStatus[WebsocketStatus["OPEN"] = 0] = "OPEN";
    WebsocketStatus[WebsocketStatus["CLOSED"] = 1] = "CLOSED";
    WebsocketStatus[WebsocketStatus["RECONNECTING"] = 2] = "RECONNECTING";
})(WebsocketStatus || (exports.WebsocketStatus = WebsocketStatus = {}));
exports.HTTPConstructorOptions = zod_1.z.object({
    fetch: zod_1.z.function().optional(),
});
function processConnectionOptions({ prepare, auth, namespace, database, }) {
    zod_1.z.function().optional().parse(prepare);
    zod_1.z.union([exports.Token, exports.AnyAuth]).optional().parse(auth);
    const useOpts = namespace || database
        ? exports.UseOptions.parse({
            namespace,
            database,
        })
        : { namespace: undefined, database: undefined };
    return { prepare, auth, ...useOpts };
}
exports.processConnectionOptions = processConnectionOptions;
//# sourceMappingURL=types.js.map